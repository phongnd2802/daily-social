// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: auth.sql

package db

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const checkUserBaseExists = `-- name: CheckUserBaseExists :one
SELECT COUNT(*)
FROM "user_base"
WHERE "user_email" = $1
`

func (q *Queries) CheckUserBaseExists(ctx context.Context, userEmail string) (int64, error) {
	row := q.db.QueryRow(ctx, checkUserBaseExists, userEmail)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createUserBase = `-- name: CreateUserBase :one
INSERT INTO "user_base" (
    "user_email",
    "user_password",
    "user_hash",
    "user_otp"
) VALUES ($1, $2, $3, $4) RETURNING user_id, user_email, user_hash, user_password, user_otp, is_verified, is_deleted, created_at, updated_at
`

type CreateUserBaseParams struct {
	UserEmail    string `json:"user_email"`
	UserPassword string `json:"user_password"`
	UserHash     string `json:"user_hash"`
	UserOtp      string `json:"user_otp"`
}

func (q *Queries) CreateUserBase(ctx context.Context, arg CreateUserBaseParams) (UserBase, error) {
	row := q.db.QueryRow(ctx, createUserBase,
		arg.UserEmail,
		arg.UserPassword,
		arg.UserHash,
		arg.UserOtp,
	)
	var i UserBase
	err := row.Scan(
		&i.UserID,
		&i.UserEmail,
		&i.UserHash,
		&i.UserPassword,
		&i.UserOtp,
		&i.IsVerified,
		&i.IsDeleted,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createUserProfile = `-- name: CreateUserProfile :one
INSERT INTO "user_profile" (
    "user_id",
    "user_email",
    "user_nickname"
) VALUES ($1, $2, $3) RETURNING user_id, user_email, user_nickname, user_fullname, user_avatar, user_mobile, user_gender, user_birthday, created_at, updated_at
`

type CreateUserProfileParams struct {
	UserID       int64  `json:"user_id"`
	UserEmail    string `json:"user_email"`
	UserNickname string `json:"user_nickname"`
}

func (q *Queries) CreateUserProfile(ctx context.Context, arg CreateUserProfileParams) (UserProfile, error) {
	row := q.db.QueryRow(ctx, createUserProfile, arg.UserID, arg.UserEmail, arg.UserNickname)
	var i UserProfile
	err := row.Scan(
		&i.UserID,
		&i.UserEmail,
		&i.UserNickname,
		&i.UserFullname,
		&i.UserAvatar,
		&i.UserMobile,
		&i.UserGender,
		&i.UserBirthday,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createUserSession = `-- name: CreateUserSession :one
INSERT INTO "user_session" (
    "session_id",
    "refresh_token",
    "user_agent",
    "client_ip",
    "user_login_time",
    "expires_at",
    "user_id"
) VALUES ($1, $2, $3, $4, $5, $6, $7) RETURNING session_id, user_id, refresh_token, user_agent, client_ip, is_blocked, user_login_time, user_logout_time, expires_at, created_at
`

type CreateUserSessionParams struct {
	SessionID     uuid.UUID          `json:"session_id"`
	RefreshToken  string             `json:"refresh_token"`
	UserAgent     string             `json:"user_agent"`
	ClientIp      string             `json:"client_ip"`
	UserLoginTime pgtype.Timestamptz `json:"user_login_time"`
	ExpiresAt     time.Time          `json:"expires_at"`
	UserID        int64              `json:"user_id"`
}

func (q *Queries) CreateUserSession(ctx context.Context, arg CreateUserSessionParams) (UserSession, error) {
	row := q.db.QueryRow(ctx, createUserSession,
		arg.SessionID,
		arg.RefreshToken,
		arg.UserAgent,
		arg.ClientIp,
		arg.UserLoginTime,
		arg.ExpiresAt,
		arg.UserID,
	)
	var i UserSession
	err := row.Scan(
		&i.SessionID,
		&i.UserID,
		&i.RefreshToken,
		&i.UserAgent,
		&i.ClientIp,
		&i.IsBlocked,
		&i.UserLoginTime,
		&i.UserLogoutTime,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const getUserBaseByEmail = `-- name: GetUserBaseByEmail :one
SELECT user_id, user_email, user_hash, user_password, user_otp, is_verified, is_deleted, created_at, updated_at 
FROM "user_base"
WHERE "user_email" = $1
`

func (q *Queries) GetUserBaseByEmail(ctx context.Context, userEmail string) (UserBase, error) {
	row := q.db.QueryRow(ctx, getUserBaseByEmail, userEmail)
	var i UserBase
	err := row.Scan(
		&i.UserID,
		&i.UserEmail,
		&i.UserHash,
		&i.UserPassword,
		&i.UserOtp,
		&i.IsVerified,
		&i.IsDeleted,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateUserVerify = `-- name: UpdateUserVerify :one
UPDATE "user_base"
SET "is_verified" = true
WHERE "user_hash" = $1 RETURNING user_id, user_email, user_hash, user_password, user_otp, is_verified, is_deleted, created_at, updated_at
`

func (q *Queries) UpdateUserVerify(ctx context.Context, userHash string) (UserBase, error) {
	row := q.db.QueryRow(ctx, updateUserVerify, userHash)
	var i UserBase
	err := row.Scan(
		&i.UserID,
		&i.UserEmail,
		&i.UserHash,
		&i.UserPassword,
		&i.UserOtp,
		&i.IsVerified,
		&i.IsDeleted,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
